## Задача 2.2
Дано уравнение $f(x) = 0$. Найти все корни уравнения с заданной точностью $\varepsilon = 10^{-12}$ на указанном отрезке $[a, b]$. Для решения задачи использовать метод Ньютона и метод простых итераций. Сравнить количество итераций, потребовавшихся для достижения заданной точности каждым методом.
$f(x) = 10^{-\sqrt{x}}- \sin(\pi \sqrt{x})- 0.9,$
$x \in [0, 3].$
### Решение
Найдем отрезки локализации для каждого корня и середины этих отрезков примим за начальные приближения.
![[221.png]]

Составим программу вычисления корня методом Ньютона, предусмотрев в ней подсчёт числа итераций. Найдем с заданной точностью корни уравнения на отрезке $[0, 3]$.
```python
def newton(x0, func, dfunc, eps):
    x1 = x0 - func(x0) / dfunc(x0)
    it = 1
    while abs(x1 - x0) > eps:
        x0 = x1
        x1 = x0 - func(x0) / dfunc(x0)
        # print(f"\t{x1}")
        it += 1
    print(f"\tВыполнено {it} итераций. x = {x1}")
    return x1
```
Результаты для каждого из отрезков локализации:
```
Выполнено 5 итераций. x = 0.000343705625
Выполнено 4 итераций. x = 1.755702317447
Выполнено 4 итераций. x = 2.751734381135
```

Составим программу вычисления корня методом простых итераций, предусмотрев в ней подсчёт числа итераций. Найдем с заданной точностью те же корни уравнения.
```python
def MPI(x0, m1, M1, f, eps):
    alpha = 2 / (m1 + M1)
    q = abs((M1-m1)/ (M1 + m1))
    x1 = x0 - alpha * f(x0)
    it = 1
    while abs(x1 - x0) > (1 - q) * eps / q:
        x0 = x1
        x1 = x0 - alpha * f(x0)
        it += 1
    
    print(f"\tВыполнено {it} итераций. x = {x1}")
    return x1
```
Результаты для каждого из отрезков локализации:
```
Выполнено 1 итераций. x = 0.0005
Выполнено 7 итераций. x = 1.755702317447
Выполнено 7 итераций. x = 2.751734381135
```

Полученные результаты запишем в таблицу:

Модифицируем методы так, чтобы каждый метод делал заданное количество итераций и на каждом шаге сохранял значение модуля невязки $r_n = |f(x_n)|$.
```python
def newton2(x0, func, dfunc, n, eps):
    x1 = x0 - func(x0) / dfunc(x0)
    r = [abs(f(x1))]
    it = 1
    while it < n:
        x0 = x1
        x1 = x0 - func(x0) / dfunc(x0)
        r.append(abs(f(x1)))
        it += 1
    return x1, np.array(r)

def MPI2(x0, m1, M1, f, n, eps):
    alpha = 2 / (m1 + M1)
    q = abs((M1-m1)/ (M1 + m1))
    x1 = x0 - alpha * f(x0)
    r = [abs(f(x1))]
    it = 1
    while it < n:
        x0 = x1
        x1 = x0 - alpha * f(x0)
        r.append(abs(f(x1)))
        it += 1
    return x1, np.array(r)
```
Для каждого начального приближения вызовем модифицированные методы так, чтобы они проделали 10 итераций. Построим графики зависимости $r_n$ от $n$ в логарифмической шкале.
![[222_0.png]]
![[222_1.png]]
![[222_2.png]]